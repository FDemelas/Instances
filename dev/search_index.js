var documenterSearchIndex = {"docs":
[{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"The implemented Lagrangian relaxation of the GA problem is the one obtained by dualizing:","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"max_bmx  sum_i in I sum_j in J p_ijx_ij","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"For i in I, let pi_i geq 0 be the Lagrangian multipliers associated to the constraint with item i. For each bin j the subproblem becomes:","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"beginalign*\n(LR_j(bmpi)) quad  max_bmx sum_i in Isum_j in J (p_ij-pi_i) x_ij span span\n sum_i in Iw_ijx_ij leq c_j\n x_ij in 01  forall i in I\nendalign*","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"It corresponds to an integer knapsack with I binary variables. For bmpige bm0, the Lagrangian bound LR(bmpi) is:","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"    LR(bmpi) = sum_j in JLR_j(bmpi)+sum_i in Ipi_i","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"The Lagrangian dual can be then written as:","category":"page"},{"location":"lagrangianSubProblem_GA/","page":"GA","title":"GA","text":"    min_bmpi in R^I_geq 0LR(bmpi)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"For the moment the function that reads the instance from file only support one data format for each problem type.","category":"page"},{"location":"instanceFormat/#Multi-Commodity-Network-Design","page":"File Format","title":"Multi Commodity Network Design","text":"","category":"section"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"For this problem the format is ... the one presented in [1] numberofnodes numberofarcs numberofcommodities for each arc):","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"head tail activationcost capacity numberof_commodities\nfor each commodity:( \ncommodtyindex routingcost capacityforcommodity","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":") for each commodity:(","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each node:(\nnodeindex rhsflow_constraint","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":") )","category":"page"},{"location":"instanceFormat/#Generalized-Assignment","page":"File Format","title":"Generalized Assignment","text":"","category":"section"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"The format for the Generalized Assignement Problem is the same of the one of OR-lib [2].","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"number of different problem sets (P)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each problem set p (p=1,...,P) in turn: -\t number of agents (m), number of jobs (n)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each agent i (i=1,...,m) in turn:","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"cost of allocating job j to agent i (j=1,...,n)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each agent i (i=1,...,m) in turn:","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"resource consumed in allocating job j to agent i (j=1,...,n)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"resource capacity of agent i (i=1,...,m)","category":"page"},{"location":"instanceFormat/#Capacitated-Warehose-Location","page":"File Format","title":"Capacitated Warehose Location","text":"","category":"section"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"The format for the Capacitated Warehouse Problem is the same of the one of OR-lib [2]:","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"number of potential warehouse locations (m), number of customers (n)","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each potential warehouse location i (i=1,...,m):  -\tcapacity, fixed cost","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"for each customer j (j=1,...,n):  -\tdemand, cost of allocating","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"all of the demand of j to warehouse i (i=1,...,m)","category":"page"},{"location":"instanceFormat/#Unit-Commitment","page":"File Format","title":"Unit Commitment","text":"","category":"section"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"Also for the Unit Commitment Problem the data format is the same of OR-lib [2]. First used and presented in [3] and [4]","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"[1]: Crainic, T. G., Frangioni, A., and Gendron, B. Bundle-based relaxation methods for multicommodity capacitated fixed charge network design. Discrete Applied Mathematics, 112(1-3):pp. 73–99, 2001.","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"[2]: http://people.brunel.ac.uk/~mastjjb/jeb/info.html","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"[3]: Frangioni, C. Gentile, F. Lacalandra 'Solving Unit Commitment Problems with General Ramp Contraints' International Journal of Electrical Power and Energy Systems, to appear, 2008","category":"page"},{"location":"instanceFormat/","page":"File Format","title":"File Format","text":"[4]: Frangioni, C. Gentile 'Solving Nonlinear Single-Unit Commitment Problems with Ramping Constraints' Operations Research 54(4), p. 767 - 775, 2006 These papers also describe in details the Unit Commitment model.","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"A Lagrangian relaxation of the CFL problem is obtained by dualizing \\eqref{cfl:customerService}. In that case, the Lagrangian dual gives a better bound than the continuous relaxation \\citep{geoffrionlagrangean1974} while the relaxed problem can be solved efficiently as it decomposes by facility. Let pi^k be the Lagrangian multiplier of constraint~\\eqref{cfl:customerService} associated with customer k in K. The relaxed problem LR(pi) is given by:","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"(LR(pi)) quad  min_(xy) text satisfies eqrefcflcapa-eqrefcflyBinary sum_j in Jf_jy_j + sum_k in K q^kpi^k +  sum_j in J  sum_k in K (r_j^k - pi^k)x_j^k","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"The relaxed problem LR(pi) can be decomposed by facility and the sub-problem associated with facility jin J is the following:","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"beginalign*\n\t(LR_j(pi)) quad  min f_jy_j +sum_k in K (r_j^k - pi^k)x_j^k   \n\tst                sum_k in K x_j^k leq c_jy_j    \n\t                    0 leq x_j^k leq q^k    forall k in K \n\t                    y_j in 01 \nendalign*","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"The value of the relaxed Lagrangian problem LR(pi) is equal to sum_j in J  LR_j(pi) +  sum_k in K q^kpi^k. LR(pi) contains only one non-continuous variable. If y_j = 0 equals 0, then x_j^k = 0 by constraints \\eqref{cflRLj:capa} and \\eqref{cflRLj:xBounds}. If y_j = 1, then the problem reduces to a continuous knapsack problem which can be solved by ordering the customers following decreasing values r_j^k - pi^k and setting x_j to maxminq^k c_j - sum_k in K(k) q^k 0 where K(k) denotes the set of customers that precede k in the order. Solving LR_j(pi) consists of choosing among these two solutions the one which is minimum so LR_j(pi) can be solved in O(Klog(K)). % By Lagrangian duality theory, a lower bound of the CFL problem is provided by the value LR(pi)=sum_j=1^Mcdot hatLR_j(pi)-sum_i=1^Npi_i. The best Lagrangian lower bound for CFL can be found by solving the Lagrangian dual problem:","category":"page"},{"location":"lagrangianSubProblem_CWL/","page":"CWL","title":"CWL","text":"\tmax_piin mathbbR^KLR(pi)","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"We use the same formulation used in [1], one of the standard formulations in literature, also called 3-binary variable formulation by [2].","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"Given G generator and T number of time periods where decisions are taken the Unit Commitment problem consists asking that generators meet all the demand P^d_t in each time period t, but also keeping a sufficient amount of backup of backup P^r_t that can be activated quickly. It is further required that each generator power output has to be taken in its minimum/maximum limits P_g^minmax, and their power outputs can change within ramp down/up rates P^rdru_g when the generator is operativeng and P^susd_g when the generator startup/shutdown. Finally, if a generator is switched on/off it should stay on/off for a given time period T^ud_g","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"The solution should minimize a total cost composed by","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"a no-load cost C^nl_g of generator g that we have to pay only to keep the generator is on\na marginal cost C^mr_g of generator g that we pay for generating one unit of power with generator g.\na startup cost C^up_g  that we pay to turn on the generator g ","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"We consider the following variables:","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"for each generator gin 1cdots G and for each period tin1cdots T a  binary variable alpha_gt to represent if the generator g is on in the period t\nfor each generator gin 1cdots G and for each period tin1cdots T a binary variable  gamma_gt to represent if the generator g starts up in the preiod t\nfor each generator gin 1cdots G and for each period tin1cdots T a binary variable eta_gt to represent if the generator shut down in the preiod ŧ\nfor each generator gin 1cdots G and for each period tin1cdots T a non-negative variables p_gt to represent the power output of the generator g in period t.","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"and then the problem can be described as","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"beginalign*\nmin  sum_t=1^Tsum_g=1^Gleft( C_g^nlalpha_gt + C_g^mrp_gt + C_g^upgamma_gt right)\n      sum_g=1^Gp_gtgeq P^d_t  t=12cdotsT \n      sum_g=1^G (P^max_galpha_gt-p_gt)  t=12cdotsT \n      P_g^minleq p_gt leq P^max_galpha_gt  g=12cdotsGt=2cdotsT\n      p_gt-p_gt-1 leq P^ru_galpha_gt-1+P_g^sugamma_gt  g=12cdotsGt=2cdotsT \n      p_gt-1-p_gt leq P^rd_galpha_gt+P^sd_geta_gt  g=12cdotsGt=12cdotsT \n      sum_u=maxt-T^u_g+11gamma_gu leq alpha_gt  g=12cdotsGt=12cdotsT  \n      sum_u=maxt-T^u_g+11eta_gu leq 1-alpha_gt  g=12cdotsGt=12cdotsT  \n      alpha_gt - alpha_gt-1 = gamma_gt - eta_gt  g=12cdotsGt=23cdotsT \n      1 geq gamma_gt+eta_gt  g=12cdotsGt=12cdotsT \n      alpha_gt in 01  g=1cdotsGt=1cdotsT \n      gamma_gt in 01  g=1cdotsGt=1cdotsT \n      eta_gt in 01  g=1cdotsGt=1cdotsT \n      p_gt geq 0      alpha_gt in 01  g=1cdotsGt=1cdotsT\nendalign*","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"[1]: Sugishita, N., Grothey, A., and McKinnon, K. Use of Machine Learning Models to Warmstart Column Generation for Unit Commitment. INFORMS Journal on Computing, January 2024.","category":"page"},{"location":"UC/","page":"UC","title":"UC","text":"[2]: Ostrowski, J., M. F. Anjos, and A. Vannelli (2012). “Tight mixed integer linear programming formulations for the unit commitment problem”. In: IEEE Transactions on Power Systems 27.1, pp. 39–46.","category":"page"},{"location":"api/#API-for-Instances.jl","page":"API reference","title":"API for Instances.jl","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Public","page":"API reference","title":"Public","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Instances]\nPrivate = false","category":"page"},{"location":"api/#Instances.CWLinstanceFactory","page":"API reference","title":"Instances.CWLinstanceFactory","text":"Abstract Factory for every instance of the Capacitated Warehose Locaation Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.GAinstanceFactory","page":"API reference","title":"Instances.GAinstanceFactory","text":"Abstract Factory for every instance of the Generalized Assignment Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.MCNDinstanceFactory","page":"API reference","title":"Instances.MCNDinstanceFactory","text":"Abstract type for the Multi Commodity Network Design Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.abstractInstance","page":"API reference","title":"Instances.abstractInstance","text":"Abstract type for the instances.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.abstractInstanceFactory","page":"API reference","title":"Instances.abstractInstanceFactory","text":"Abstract type for the instance factories.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.abstractInstanceMCND","page":"API reference","title":"Instances.abstractInstanceMCND","text":"Abstract type for every instance of the Multi Commodity Network Design Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuCWLinstanceFactory","page":"API reference","title":"Instances.cpuCWLinstanceFactory","text":"Factory structure used to construct an instance of the Bin Packing Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuGAinstanceFactory","page":"API reference","title":"Instances.cpuGAinstanceFactory","text":"Factory structure used to construct an instance of the Bin Packing Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuInstanceCWL","page":"API reference","title":"Instances.cpuInstanceCWL","text":"Structure that describe a cpu instance of the Capacitated Warehose Location Problem.\n\nFields:\n\n-I: facilities number -J: custumers number -c: costs to satisfy the demand of a costumer with a certain facility  -f: costs for open facilities -q: capacity of the facilities -d: demands of the costumers\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuInstanceGA","page":"API reference","title":"Instances.cpuInstanceGA","text":"Structure that describe an instance of the Generalized Assignment Problem.\n\nFields:\n\nI: number of items\nJ: number of bins\np: profit matrix\nw: weights matrix\nc: capacities of the bins\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuInstanceMCND","page":"API reference","title":"Instances.cpuInstanceMCND","text":"Structure to describe  a MCND instance in such a way that the sub-problem can be solved using CPU.\n\nFields:\n\nn : nombre de sommets\nedges` : table of arcs: [(tₑ,hₑ)]ₑ\nK : table of commodities: [(oᵏ, dᵏ, qᵏ)]ₖ\nf : fixed costs\nr : routing costs\nc : capacities of arcs \n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.cpuMCNDinstanceFactory","page":"API reference","title":"Instances.cpuMCNDinstanceFactory","text":"Structure for the cpu instance of the Multi Commodity Network Design Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.gpuMCNDinstance","page":"API reference","title":"Instances.gpuMCNDinstance","text":"Structure to describe  a MCND instance in such a way that the sub-problem can be solved using GPU.\n\nFields:\n\nn : nombre de sommets\nedges` : table of arcs: [(tₑ,hₑ)]ₑ\nK : table of commodities: [(oᵏ, dᵏ, qᵏ)]ₖ\nf : fixed costs\nr : routing costs\nc : capacities of arcs \n...: other technical parameters that are used for the GPU-computations of the Lagrangian Sub-Problem and are computed just once.\n\n\tIt is not mandatory to provide these parameters to the constructor as they can be automatically constructed starting from the  ones shared with the cpu version of the instance.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.instanceCWL","page":"API reference","title":"Instances.instanceCWL","text":"Abstract type for every instance of the Capacitated Warehose Locaation Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.instanceGA","page":"API reference","title":"Instances.instanceGA","text":"Abstract type for every instance of the Generalized Assignment Problem.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.CR-Tuple{Instances.UC_instance}","page":"API reference","title":"Instances.CR","text":"Arguments:\n\nins: an instance structure of type UC_instance.\n\nSolve the linear relaxation of the provided instance and then, it returns the objective value of the linear relaxation, the dual variables associated to flow constraints, the dual variables associated to capacity constraints, the primal flow variables and the primal design variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.CR-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.CR","text":"Arguments:\n\nins: an instance structure.\n\nSolve the linear relaxation of the provided instance and then, it returns the objective value of the linear relaxation, the dual variables associated to flow constraints, the dual variables associated to capacity constraints, the primal flow variables and the primal design variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.CR-Tuple{cpuInstanceCWL}","page":"API reference","title":"Instances.CR","text":"Arguments:\n\nins: a CWL instance structure.\n\nSolve the linear relaxation of the provided instance and then, it returns the objective value of the linear relaxation, the dual variables associated to packing constraints, the dual variables associated to capacity constraints, the primal assigment variables and the primal pack activation variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.CR-Tuple{cpuInstanceGA}","page":"API reference","title":"Instances.CR","text":"Arguments:\n\nins: a GA instance structure.\n\nSolve the linear relaxation of the provided instance and then, it returns the objective value of the linear relaxation, the dual variables associated to packing constraints, the dual variables associated to capacity constraints, the primal assigment variables and the primal pack activation variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.LR-Tuple{cpuInstanceCWL, Any}","page":"API reference","title":"Instances.LR","text":"Arguments:\n\n-ins: an instance structure of the Bin packing Problem, -π: a vector of Lagrangian Multipliers,\n\nunsplittable: a boolean that say if true that is the unsplittable version of CWL where we have only binary variables.\n\nThis function solves the Lagrangian Knapsack Sub-Problem for the provided instance using the provided Lagrangian multipliers vector. \n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.LR-Tuple{cpuInstanceGA, Any}","page":"API reference","title":"Instances.LR","text":"Arguments:\n\n-ins: an instance structure of the Bin packing Problem -π: a vector of Lagrangian Multipliers\n\nThis function solves the Lagrangian Knapsack Sub-Problem for the provided instance using the provided Lagrangian multipliers vector. \n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.LR-Tuple{cpuInstanceMCND, Any}","page":"API reference","title":"Instances.LR","text":"Arguments:\n\nins: cpuInstanceMCND of the problem\nπ: a Lagrangian multipliers Vector\n\nCompute LR. regY is the regularization vector for y and α a multiplicative parameter. It does not requires the solution vector x,y as input and it return them as output.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.LR-Tuple{cpuInstanceMCND, Vararg{Any, 5}}","page":"API reference","title":"Instances.LR","text":"Arguments:\n\n- `ins`: cpuInstanceMCND of the problem\n- `π`: a Lagrangian multipliers Vector\n- (`x`,`y`): two vector of the same size of the (primal) solution vector for the sub-problem, not initalized.\n- `demands`: a vector [1:K] with the (unsorted) incexes for the demands\n- `e`: index of the arc\n\nCompute LR_{ij}, the value of the Lagrangian problem associated with arc of index e.\nIt requires the solution vector x,y as input and update them durnig the resolution.\n\nDemands is a permutation of 1:p.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.LR-Tuple{gpuMCNDinstance, Any}","page":"API reference","title":"Instances.LR","text":"ins: a gpuMCNDinstance to encode the problem\nz: a Lagrangian multipliers Vector\n\nCompute LR using the GPU.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.b-Tuple{abstractInstanceMCND, Any, Any}","page":"API reference","title":"Instances.b","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `i`: the index of the node.\n- `k`: the index of the commodity.\n\nGiven a certain node and a certain commodity, this function\nreturns the volume of the demand for the commodity, if the node \nis the origin, the inverse of the volume if the node is the destination\nand zero otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.capacity-Tuple{abstractInstanceMCND, Any}","page":"API reference","title":"Instances.capacity","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `e`: the index of the edge.\n\nReturns the capacity of arc ij (that is j)\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.cijk-Tuple{cpuInstanceMCND, Any, Any, Any}","page":"API reference","title":"Instances.cijk","text":"Arguments:\n\n- `ins`: instance of the problem\n- `e`: index of the edge\n- `k`: index of the commodity\n- `π`: a Lagrangian multipliers Vector\n\nReturn the cost associated with demand k in the subproblem of L(π) related to arc e\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.constantLagrangianBound-Tuple{cpuInstanceMCND, Any}","page":"API reference","title":"Instances.constantLagrangianBound","text":"Arguments:\n\n- `ins`: cpuInstanceMCND of the problem\n- `π`: a Lagrangian multipliers Vector\n\nCompute the component of the bound that does not depends by the soluyion x,y of the sub-problem,\nbut only by the lagrangian multipliers vector and the demands data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_data_object-Tuple{Int64, Int64, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Vector{Float32}, Any}","page":"API reference","title":"Instances.create_data_object","text":"Arguments:\n\nG : number of generators\nT : time horizon\nC_no_load : no load cost\nC_marginal : marginal cost\nC_startup : startup cost\nP_max_gen : maximum power generation \nP_min_gen : minimum power generation  \nP_ramp_up : up-ramp factor when working\nP_ramp_down : down-ramp factor  when working\nP_startup_ramp : up-ramp factor when startup\nP_shutdown_ramp: down-ramp factor when shutdown\nT_startup_time : minimum time required to be on when the generator is startup\nT_shutdown_time: minimum time required to be off when the generator is shutdown\nPd_power_demend: power demand\n`Prreserverequirement: power requirement\nmodel: the JuMP model that describe the instance\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_data_object-Tuple{cpuCWLinstanceFactory, Int64, Int64, Matrix{Float32}, Vector{Float32}, Vector{Int64}, Vector{Int64}}","page":"API reference","title":"Instances.create_data_object","text":"Given the data, creates an instance of the Bin Packing Problem.\n\nArguments:\n\n_: factory\nI: number of facilities\nJ: number of custumers\n\n-c: costs to satisfy the demand of a costumer with a certain facility  -f: costs for open facilities -q: capacity of the facilities -d: demands of the costumers\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_data_object-Tuple{cpuGAinstanceFactory, Vararg{Any, 5}}","page":"API reference","title":"Instances.create_data_object","text":"Arguments:\n\n_: factory of type cpuGAinstanceFactory\nI: number of items\nJ: number of bins\np: profit matrix\nw: weights matrix\nc: capacities of the bins\n\nGiven the data, creates an instance of the Bin Packing Problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_data_object-Tuple{cpuMCNDinstanceFactory, Vararg{Any, 6}}","page":"API reference","title":"Instances.create_data_object","text":"Arguments:\n\n::cpuMCNDinstanceFactory: The standard instance factory formulation.\nn: The number of node in the graph that defines the instance.\nedges: An array of tuble (size ℤ²ˣᴱ), for each edge 'e' we have a tuple defined as (start(e),end(e))\n\n\twith the starting end ending node for that arc.\n\nK: An array of triplet (with size ℤᵏˣ³), for each commodity k the associated component is (oᵏ,dᵏ,qᵏ), i.e. the origin, destination and volume of the commodity.\nf: The vector of fixed costs ( ∈ ℝᴱ)\nr: The vector of routing costs ( ∈ ℝᴷˣᴱ)\nc: The vector of capacities ( ∈ ℝᴱ)\n\nIt create an instance structure ( for an instance in the standard formulation) with the provided inputs data. \n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_data_object-Tuple{gpuMCNDinstanceFactory, Vararg{Any, 6}}","page":"API reference","title":"Instances.create_data_object","text":"createdataobject(::gpuMCNDinstanceFactory, n, edges, K, f, r, c)\n\nArguments:\n\n::gpuMCNDinstanceFactory: The standard instance factory formulation.\nn: The number of node in the graph that defines the instance.\nedges: An array of tuble (size ℤ²ˣᴱ), for each edge 'e' we have a tuple defined as (start(e),end(e))\n\n\twith the starting end ending node for that arc.\n\nK: An array of triplet (with size ℤᵏˣ³), for each commodity k the associated component is (oᵏ,dᵏ,qᵏ), i.e. the origin, destination and volume of the commodity.\nf: The vector of fixed costs ( ∈ ℝᴱ)\nr: The vector of routing costs ( ∈ ℝᴷˣᴱ)\nc: The vector of capacities ( ∈ ℝᴱ)\n\nIt create an instance structure ( for an instance in the standard formulation) with the provided inputs data. \n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.destination-Tuple{abstractInstanceMCND, Any}","page":"API reference","title":"Instances.destination","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `indexk`: the index of the commodity.\n\nReturns the destination node of the demand k\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.fixed_cost-Tuple{abstractInstanceMCND, Any}","page":"API reference","title":"Instances.fixed_cost","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `e`: the index of the edge.\n\nReturns the fixed cost of arc e\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.generate_GA-Tuple{Int64, Int64, Int64}","page":"API reference","title":"Instances.generate_GA","text":"Arguments:\n\nseed: random generator seed.\nI: number of items.\nJ: number of bins.\n\nreturn an instance with I items and J bins generating the weights as:\n\nwᵢⱼ = 1 - 10⋅ϵᵢⱼ \n\nthe profits as:\n\npᵢⱼ = wᵢⱼ/1000 - 10 ⋅ δᵢⱼ\n\nwhere ϵᵢⱼ, δᵢⱼ are random values in (0,1).\n\nThe capacities are genrated as:\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.head-Tuple{abstractInstanceMCND, Int64}","page":"API reference","title":"Instances.head","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `indexe`: the index of the edge.\n\nReturns the head of arc ij (that is j)\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.indegree-Tuple{abstractInstanceMCND, Integer}","page":"API reference","title":"Instances.indegree","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `i`: the index of the node.\n\nReturns the indegree of i\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.indegree_k-Tuple{abstractInstanceMCND, Integer, Integer}","page":"API reference","title":"Instances.indegree_k","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `i`: the index of the node.\n- `k`: the index of the commodity.\n\nReturns the indegree of i for a given commodity k\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.isInKij-Tuple{abstractInstanceMCND, Any, Any}","page":"API reference","title":"Instances.isInKij","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `e`: the index of the edge.\n- `k`: the index of the commodity.\n\nReturns True if k is in Kij\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.lengthLM-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.lengthLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceGA\n\nreturns the length of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.lengthLM-Tuple{instanceCWL}","page":"API reference","title":"Instances.lengthLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceCWL\n\nreturns the length of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.lengthLM-Tuple{instanceGA}","page":"API reference","title":"Instances.lengthLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceGA\n\nreturns the length of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.modify_instance-Tuple{cpuInstanceMCND, Int64, Real}","page":"API reference","title":"Instances.modify_instance","text":"Arguments:\n\n-ins: an instance object cpuInstanceMCND,  -seed: the random generation seed -x: a number that allows to increase/decrease the number of demands/commodities in the instance as size(newdemands)=round(x*size(newdemands))\n\nreturn an instance generated straing from ins and perturbing the routing costs, the volumes, the origins and the destinations of the demands. Furthermore it is possible to change the number of demands with the parameter x.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.objective_coefficient_type-Tuple{abstractInstanceFactory}","page":"API reference","title":"Instances.objective_coefficient_type","text":"Returns the type of the objective for an instance in the standard formulation, that is Int16. \n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.origin-Tuple{abstractInstanceMCND, Any}","page":"API reference","title":"Instances.origin","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `indexk`: the index of the commodity.\n\nReturns the origin node of the demand k\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.outdegree-Tuple{abstractInstanceMCND, Integer}","page":"API reference","title":"Instances.outdegree","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `i`: the index of the node.\n\nReturns the outdegree of i\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.outdegree_k-Tuple{abstractInstanceMCND, Integer, Integer}","page":"API reference","title":"Instances.outdegree_k","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `i`: the index of the node.\n- `k`: the index of the commodity.\n\nReturns the outdegree of i for a given commodity k\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.print_dat-Tuple{String, cpuInstanceMCND}","page":"API reference","title":"Instances.print_dat","text":"Arguments:\n\n\t- `path`: the path to the file where we want print the data\n\t- `ins`: the instance object that we want print in a file, should be a cpuInstanceMCND\n\nprint the instance ins in the file in path.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.print_dat-Tuple{String, instanceCWL}","page":"API reference","title":"Instances.print_dat","text":"Arguments:\n\n\t- `path`: the path to the file where we want print the data\n\t- `ins`: the instance object that we want print in a file, should be a sub-type of instanceCWL\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.print_dat-Tuple{String, instanceGA}","page":"API reference","title":"Instances.print_dat","text":"Arguments:\n\n\t- `path`: the path to the file where we want print the data\n\t- `ins`: the instance object that we want print in a file, should be a <: instanceGA\n\nprint the instance in a .dat file.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.read_dat","page":"API reference","title":"Instances.read_dat","text":"Arguments:\n\npath: a string specifying the path to the file\nfactory: a factory that allows to return the correct instance type, for this function should be cpuUCinstanceFactory  \ndecomposable: a boolean that say if memorize the problems as decomposed sub-problems.\n\nread a data from the file in path and return an instance assocated to the factory.\n\n\n\n\n\n","category":"function"},{"location":"api/#Instances.read_dat-Tuple{String, cpuCWLinstanceFactory}","page":"API reference","title":"Instances.read_dat","text":"Arguments:\n\npath : a String that contains the path to the data file of the instance\nfactory : a cpuCWLinstanceFactory used only to construct an instance of the proper type ( . <: instanceCWL)\n\nGiven the path and the factory of the proper type, this function reads the instance information  from the file in the provided path and construct an instance of the Capacitated Warehouse Location problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.read_dat-Tuple{String, cpuGAinstanceFactory}","page":"API reference","title":"Instances.read_dat","text":"Arguments:\n\n-path: a String that contains the path to the data file of the instance -_: a cpuGAinstanceFactory used only to construct an instance of the proper type ( . <: instanceGA)\n\nGiven the path and the factory of the proper type, this function reads the instance information from the file in the provided path and construct an instance of the Bin Packing problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.read_dat-Tuple{String, cpuMCNDinstanceFactory}","page":"API reference","title":"Instances.read_dat","text":"Arguments:\n\n-path: a String that contains the path to the data file of the instance -factory: a cpuMCNDinstanceFactory used only to construct an instance of the proper type (cpuInstanceMCND)\n\nGiven the path and the factory of the proper type, this function reads the instance information from the file in the provided path and construct an instance of the Bin Packing problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.read_modify_dat","page":"API reference","title":"Instances.read_modify_dat","text":"Arguments:\n\npath: the path to the file .dat containing the information about the instance that we want modify\nfactory: the instance factory, supports cpuGAinstanceFactory\nseed: the random generation seed\nα : a parameter that controll the ratio of demands and capacities\nnewJ: new number of custumers\n\nreturns an instance obtained modifying the original one.\n\n\n\n\n\n","category":"function"},{"location":"api/#Instances.read_modify_dat-2","page":"API reference","title":"Instances.read_modify_dat","text":"Arguments:\n\npath: the path to the file .dat containing the information about the instance that we want modify\nfactory: the instance factory, supports cpuCWLinstanceFactory\nseed: the random generation seed\nα : a parameter that controll the ratio of demands and capacities\nnewJ: new number of custumers\n\nreturns an instance obtained modifying the original one.\n\n\n\n\n\n","category":"function"},{"location":"api/#Instances.routing_cost-Tuple{abstractInstanceMCND, Any, Any}","page":"API reference","title":"Instances.routing_cost","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `e`: the index of the edge.\n- `k`: the index of the commodity.\n\nReturns the routing cost\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeE-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.sizeE","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n\nReturns the number of arcs\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeK-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.sizeK","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n\nReturns the number of demands\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeLM-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.sizeLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceGA\n\nreturns the size of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeLM-Tuple{instanceCWL}","page":"API reference","title":"Instances.sizeLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceCWL\n\nreturns the size of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeLM-Tuple{instanceGA}","page":"API reference","title":"Instances.sizeLM","text":"Arguments:\n\nins: instance object, should be a sub-type of instanceGA\n\nreturns the size of the Lagrangian multipliers for the instance ins.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.sizeV-Tuple{abstractInstanceMCND}","page":"API reference","title":"Instances.sizeV","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n\nReturns the number of nodes\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.solve_knapsack-Tuple{Int64, Vararg{Any, 4}}","page":"API reference","title":"Instances.solve_knapsack","text":"Arguments:\n\n\t- `n`: the number of objects \n\t- `c`: the costs vector of the objects\n\t- `w`: the weights vector of the objects\n\t- `C`: the capacity of the knapsack\n\t- `x`: the decision variable vector, it should have size n, the solution will be contained in this vector after the call of the function.\n\nSolve a binary knapsack with the provided parameters, save the solution in the vector x and return the objective value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.solve_knapsack_continuous-NTuple{5, Any}","page":"API reference","title":"Instances.solve_knapsack_continuous","text":"Arguments:\n\n\t- `n`: the number of objects \n\t- `c`: the costs vector of the objects\n\t- `w`: the weights vector of the objects\n\t- `C`: the capacity of the knapsack\n\t- `x`: the decision variable vector, it should have size n, the solution will be contained in this vector after the call of the function.\n\nSolve a continuous knapsack with the provided parameters, save the solution in the vector x and return the objective value.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.tail-Tuple{abstractInstanceMCND, Int64}","page":"API reference","title":"Instances.tail","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `indexe`: the index of the edge.\n\nReturns the tail of arc ij (that is i)\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.value_LR-Tuple{cpuInstanceMCND, Any, Any, Any}","page":"API reference","title":"Instances.value_LR","text":"Arguments:\n\n- `ins`: cpuInstanceMCND of the problem\n- `π`: Lagrangian multipliers\n- (`x`, `y`): Solution of the Lagrangian problem\n\nReturn the value of the Lagrangian sub-problem associated, using the lagrangian multipliers vector π and the primal solution (x,y).\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.value_LR_a-Tuple{cpuInstanceMCND, Vararg{Any, 4}}","page":"API reference","title":"Instances.value_LR_a","text":"Arguments:\n\n- `ins`: cpuInstanceMCND of the problem\n- `ia`: index of the arc\n- `π`: Lagrangian multipliers\n- (`x`, `y`): Solution of the Lagrangian problem\n\n\nReturn the value of the Lagrangian problem associated with arc of index ia,\nusing the lagrangian multipliers vector π and the primal solution (x,y).\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.volume-Tuple{abstractInstanceMCND, Any}","page":"API reference","title":"Instances.volume","text":"Arguments:\n\n- `ins`: a normalized instance structure.\n- `indexk`: the index of the commodity.\n\nReturns the volume of the demand k\n\n\n\n\n\n","category":"method"},{"location":"api/#Private","page":"API reference","title":"Private","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [Instances]\nPublic= false","category":"page"},{"location":"api/#Instances.UC_instance","page":"API reference","title":"Instances.UC_instance","text":"Structure to describe  a UC instance in such a way that the sub-problem can be solved using CPU.\n\nFields:\n\nG : number of generators\nT : time horizon\nC_no_load : no load cost\nC_marginal : marginal cost\nC_startup : startup cost\nP_max_gen : maximum power generation \nP_min_gen : minimum power generation  \nP_ramp_up : up-ramp factor when working\nP_ramp_down : down-ramp factor  when working\nP_startup_ramp : up-ramp factor when startup\nP_shutdown_ramp: down-ramp factor when shutdown\nT_startup_time : minimum time required to be on when the generator is startup\nT_shutdown_time: minimum time required to be off when the generator is shutdown\nPd_power_demend: power demand\n`Prreserverequirement: power requirement\nmodel: the JuMP model that describe Lagrangian relaxation of the instance\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.compact_model","page":"API reference","title":"Instances.compact_model","text":"Structure that describe the Lagrangian Relaxation of an UC instance in such a way that the sub-problems are written in a unique JuMP model. This should be used only if the solver associated to the model is automatically capable to exploit the decomposable structure. \n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.decomposed_model","page":"API reference","title":"Instances.decomposed_model","text":"Structure that describe the Lagrangian Relaxation of an UC instance in such a way that the sub-problems are solved in a decomposed formulation. In other world the Lagrangian Sub-Problem are saved as independent JuMP models that are then solved sequentially, but independently.\n\n\n\n\n\n","category":"type"},{"location":"api/#Instances.create_LR-Tuple{Instances.UC_instance}","page":"API reference","title":"Instances.create_LR","text":"Arguments:\n\nins: an instance structure of type UC_instance.\n\nConstruct the Lagrangian Relaxation Sub-Problem for non-decomposed sub-problems.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.create_LR_component-Tuple{Instances.UC_instance, Int64}","page":"API reference","title":"Instances.create_LR_component","text":"Arguments:\n\nins: an instance structure of type UC_instance.\ng: the index of the generator associated to the sub-problem.\n\nConstruct the Lagrangian Relaxation Sub-Problem associated to a given generator g in the case of decomposable sub-problems.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.modify_objective-Tuple{Instances.UC_instance, AbstractVector, AbstractVector}","page":"API reference","title":"Instances.modify_objective","text":"Arguments:\n\nins: an instance structure of type UC_instance\ny1: the dual variables vector associated to Power Demand Constraints\ny2: the dual variables vector associated to Reserve Constraints\n\nFor Undecomposed sub-problem. Modify the objective function of the Lagrangian Sub-Problem in the model constained in ins considering y1 and y2 as Lagrangian Mutlipliers vectors.\n\n\n\n\n\n","category":"method"},{"location":"api/#Instances.modify_objectives-Tuple{Instances.UC_instance, AbstractVector, AbstractVector}","page":"API reference","title":"Instances.modify_objectives","text":"Arguments:\n\nins: an instance structure of type UC_instance\ny1: the dual variables vector associated to Power Demand Constraints\ny2: the dual variables vector associated to Reserve Constraints\n\nFor Decomposed sub-problem. Modify the objectives functions of the Lagrangian Sub-Problems in the model constained in ins considering y1 and y2 as Lagrangian Mutlipliers vectors.\n\n\n\n\n\n","category":"method"},{"location":"CWL/","page":"CWL","title":"CWL","text":"A CFL instance is defined by a set J of facilities and a set K of customers. With each facility j in J is associated a capacity c_j and a fixed cost f_j. A demand q^k is associated with each customer k in K. Finally, a service cost r_j^k is associated with each facility j in J and each customer k in K and corresponds to the cost of serving one unit of demand of customer k from facility j.","category":"page"},{"location":"CWL/","page":"CWL","title":"CWL","text":"A CFL solution consists in a subset of open facilities as well as the amount of demand served from these open facilities to each customer. Its cost is the sum of the fixed costs over the open facilities plus the sum over every facility j in J and every customer k in K of the unitary service cost r_j^k multiplied by the amount of demand of customer k served from facility j.","category":"page"},{"location":"CWL/#MILP-formulation","page":"CWL","title":"MILP formulation","text":"","category":"section"},{"location":"CWL/","page":"CWL","title":"CWL","text":"A standard model for the CFL \\citep{akinc77} introduces two sets of variables: the continuous variables x_j^k representing the amount of demand of customer k served from facility j, and the binary variables y_j indicating whether facility j in J is open. Hence, a formulation of the problem is:","category":"page"},{"location":"CWL/","page":"CWL","title":"CWL","text":"beginalign\n\tmin  sum_j in J left(f_jy_j + sum_k in Kr_j^kx_j^kright)       \n\tst  sum_j in J x_j^k = q^k                  forall k in K             \n\t  sum_k in K x_j^k leq c_jy_j      forall j in J               \n\t      0 leq x_j^k leq q^k                       forall j in J forall k in K  \n\t      y_jin 01                           forall j in J\nendalign","category":"page"},{"location":"GA/","page":"GA","title":"GA","text":"A Generalized Assignment (GA) instance is defined by a set I of items and a set J of bins. Each bin j is associated with a certain capacity c_j. For each item i in I and each bin j in J p_ij is the profit of assigning item i to bin j, and w_ij is the weight of item i inside bin j.","category":"page"},{"location":"GA/","page":"GA","title":"GA","text":"Considering a binary variable x_ij for each item and each bin that is equal to one if and only if item i is assigned to bin j, the GA problem can be formulated as:","category":"page"},{"location":"GA/","page":"GA","title":"GA","text":"beginalign\n max_bmx  sum_i in I sum_j in J p_ijx_ij \n sum_j in J x_ij  leq 1  forall i in I  \n sum_i in I w_ij x_ij  leq c_j  forall j in J \n x_ij in 01  forall i in I  forall jin J \nendalign","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"Let pi_i^k be the Lagrangian multiplier associated with node i in N and k in K. The Lagrangian relaxation decomposes by arcs and one obtains a subproblem for each arc (ij)in A of the form:","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"    beginalign*\n        L_ij(pi)  equivmin_x y L(pi x y) = min_x y f_ijy_ij + sum_k in K r^k_ij(pi)x_ij^k\n        st  sum_k in Kx_ij^kleq c_ijy_ij\n         0leq x^k_ijleq q^k   forall k in K \n        y_ij in 01  \n    endalign*","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"where, defining K(ij) = k in K mid j neq o(k) and i neq d(k), the function r_ij^k(pi) can be defined as:","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"r_ij^k(pi)=left\nbeginalign*\n    r_ij^k+pi_i^k-pi_j^k   textif  k in K(ij)\n    0 qquad   textotherwise\nendalign* right","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"For each (ij) in A, computing L_ij(pi) reduces to computing a continuous knapsack problem (case y_ij = 1) and to compare with 0 (case y_ij = 0).","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"Lagrangian duality implies that the value L(pi)=sum_(ij) in A L_ij(pi)- sum_i in Nsum_k in K pi_i^k b^k_i is a lower bound for the MCND and the best one is obtained by solving the following Lagrangian dual problem:","category":"page"},{"location":"lagrangianSubProblem_MCND/","page":"MCND","title":"MCND","text":"LD = max_pi in mathbbR^N times K L(pi)  ","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"We relax the constraints:","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"sum_g=1^Gp_gtgeq P^d_t qquad  t=12cdotsT with multipliers lambdain mathbbR_+^T. and","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"sum_g=1^G (P^max_galpha_gt-p_gt) qquad t=12cdotsT with multiliers muin mathbbR_+^T, obtaining a sub-problem that decomposes by generators. For a given g in G the associated sub-problem is:","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"beginalign*\nLR_g(lambdamu) equiv  min   sum_t=1^Tleft( C_g^nlalpha_gt + C_g^mrp_gt + C_g^upgamma_gt right)+ sum_t=1^Tlambda_t p_gt+ sum_t=1^T mu_t(P^max_galpha_gt - p_gt)  t=12cdotsT \n      P_g^minleq p_gt leq P^max_galpha_gt  g=12cdotsGt=2cdotsT\n      p_gt-p_gt-1 leq P^ru_galpha_gt-1+P_g^sugamma_gt  t=2cdotsT \n      p_gt-1-p_gt leq P^rd_galpha_gt+P^sd_geta_gt  t=12cdotsT \n      sum_u=maxt-T^u_g+11gamma_gu leq alpha_gt  t=12cdotsT  \n      sum_u=maxt-T^u_g+11eta_gu leq 1-alpha_gt  t=12cdotsT  \n      alpha_gt - alpha_gt-1 = gamma_gt - eta_gt  t=23cdotsT \n      1 geq gamma_gt+eta_gt  t=12cdotsT \n      alpha_gt in 01  g=1cdotsGt=1cdotsT \n      gamma_gt in 01  g=1cdotsGt=1cdotsT \n      eta_gt in 01  g=1cdotsGt=1cdotsT \n      p_gt geq 0      alpha_gt in 01  g=1cdotsGt=1cdotsT   \nendalign*","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"then the Lagrangian Dual bound can be computed as","category":"page"},{"location":"lagrangianSubProblem_UC/","page":"UC","title":"UC","text":"max_lambdamu in mathbbR^TtimesmathbbR^Tleft( sum_g=1^GLR_g(lambdamu)+sum_t=1^Tlambda_tP^d_t + sum_t=1^Tmu_tP^r_tright)","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"An instance of the multicommodity capacitated fixed-charge network design problem (FCNDP) is given by a directed simple graph D = (NA), a set of commodities K, an arc-capacity vector c and two cost vectors r and f. Each commodity kin K corresponds to a triplet (o^k d^k q^k) where o^kin N and d^kin N are nodes corresponding to the origin and the destination of the demand and q^k in mathbbN^* is its volume. For each arc (ij) in A, c_ij0 corresponds to the maximum amount of flows which can be routed through (ij) and f_ij  0 corresponds to the fixed cost of using the arc (ij) to route some flows. For each arc (ij) in A and each demand k in K, r_ij^k 0 corresponds to the cost of routing one unit of commodity k in K through the arc (ij).","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"A solution of the multicommodity capacitated fixed-charge network design problem consists in routing the demands while ensuring the capacity of the arcs. The cost of a solution is determined by the sum of the routing costs associated with each commodity and the fixed costs associated with all the arcs used for routing a demand.","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"A standard model for MCND introduces two sets of variables: the flow variables x_ij^k representing the flow of commodity k that passes through the arc (ij) and the variables y_ij representing design variables of the network, i.e. if we use or not a certain arc (ij). Hence the model is:","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"beginaligned\n    Z^MCND  =min sum_(ij) in A left( sum_k in K r^k_ijx_ij^k+f_ijy_ijright)\n     st  sum_jin N^+_ix_ij^k - sum_jin N^-_ix_ji^k=b^k_i forall i in N forall k in K \n      sum_k in Kx_ij^kleq c_ijy_ij forall (ij)in A \n      0leq x^k_ijleq q^k   forall (ij)in A forall k in K\n     y_ij in 01  forall (ij)in A \nendaligned","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"where","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"b^k_i=left\nbeginaligned\n    q^k   if  i = o^k \n    -q^k   if  i = d^k \n    0    otherwise \nendaligned\nright","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"The flows of each commodity can be restricted, without loss of generality, to not entering its origin node nor leaving its destination one. This can be done by adding the following equations in the model:","category":"page"},{"location":"MCND/","page":"MCND","title":"MCND","text":"x_ij^k = 0 for each arc (ij) in delta^rm in(o^k) cup delta^rm out(d^k)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Instances","category":"page"},{"location":"#LearningPi","page":"Home","title":"LearningPi","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Instances.","category":"page"}]
}
